import re
from pyrogram import filters, Client, enums
from pyrogram.errors.exceptions.bad_request_400 import ChannelInvalid, UsernameInvalid, UsernameNotModified
from info import ADMINS, LOG_CHANNEL, FILE_STORE_CHANNEL, PUBLIC_FILE_STORE
from database.ia_filterdb import unpack_new_file_id
from utils import temp
import re
import os
import json
import base64
import logging

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

async def allowed(_, __, message):
    if PUBLIC_FILE_STORE:
        return True
    if message.from_user and message.from_user.id in ADMINS:
        return True
    return False

@Client.on_message(filters.command(['link', 'plink']) & filters.create(allowed))
async def gen_link_s(bot, message):
    replied = message.reply_to_message
    if not replied:
        return await message.reply('ğšğ™´ğ™¿ğ™»ğšˆ ğšƒğ™¾ ğ™° ğ™¼ğ™´ğš‚ğš‚ğ™°ğ™¶ğ™´ ğ™¾ğš ğ™° ğ™µğ™¸ğ™»ğ™´. ğ™¸ ğš†ğ™¸ğ™»ğ™» ğ™¶ğ™¸ğš…ğ™´ ğšˆğ™¾ğš„ ğ™° ğš‚ğ™·ğ™°ğšğ™°ğ™±ğ™»ğ™´ ğ™¿ğ™´ğšğ™¼ğ™°ğ™½ğ™´ğ™½ğšƒ ğ™»ğ™¸ğ™½ğ™º')
    file_type = replied.media
    if file_type not in [enums.MessageMediaType.VIDEO, enums.MessageMediaType.AUDIO, enums.MessageMediaType.DOCUMENT]:
        return await message.reply("ğšğ™´ğ™¿ğ™»ğšˆ ğšƒğ™¾ ğ™° ğš‚ğš„ğ™¿ğ™¿ğ™¾ğšğšƒğ™´ğ™³ ğ™¼ğ™´ğ™³ğ™¸ğ™°")
    if message.has_protected_content and message.chat.id not in ADMINS:
        return await message.reply("ğ™¾ğ™º ğ™±ğšğ™¾")
    file_id, ref = unpack_new_file_id((getattr(replied, file_type)).file_id)
    string = 'filep_' if message.text.lower().strip() == "/plink" else 'file_'
    string += file_id
    outstr = base64.urlsafe_b64encode(string.encode("ascii")).decode().strip("=")
    await message.reply(f"<b>âª¼ ğ™·ğ™´ğšğ™´ ğ™¸ğš‚ ğšˆğ™¾ğš„ğš ğ™»ğ™¸ğ™½ğ™º:</b>\n\nhttps://t.me/{temp.U_NAME}?start={outstr}")
    
    
